---
name: Comprehensive Testing
overview: Add comprehensive tests for filename parsing, manifest serialization, replayer term logic, cloud integration, and all term-aware functionality.
todos:
  - id: filename-parsing-tests
    content: Add tests for filename parsing with supported formats (term-aware + term=0 compatibility)
    status: completed
  - id: manifest-serialization-tests
    content: Add tests for FileIdTermMapping serialization/deserialization
    status: completed
  - id: replayer-term-tests
    content: Add tests for replayer term validation and allocator bumping
    status: completed
  - id: cloud-integration-tests
    content: Add tests for cloud manifest selection and file operations with terms
    status: completed
---

# Phase 11: Comprehensive Testing

## Overview

Add comprehensive test coverage for all term-aware functionality including filename parsing, manifest serialization, replayer term validation, cloud integration, and end-to-end scenarios.

## Implementation Steps

### 11.1 Filename parsing tests

**Goal**: Test ParseFileName and filename generators with all formats.

**Steps**:
1. Create test file `tests/filename_test.cpp` or extend existing test
2. Test `ParseFileName` with supported formats:
   - `data_<id>` → term=0
   - `manifest` → term=0
3. Test `ParseFileName` with term-aware formats:
   - `data_<id>_<term>` → term extracted
   - `manifest_<term>` → term extracted
   - `manifest_<term>_<ts>` → term and ts extracted
4. Test filename generators:
   - `DataFileName(file_id, 0)` → legacy format
   - `DataFileName(file_id, term)` → term-aware format
   - `ManifestFileName(0)` → legacy format
   - `ManifestFileName(term)` → term-aware format
   - `ArchiveName(0, ts)` → legacy format
   - `ArchiveName(term, ts)` → term-aware format
5. Test roundtrip:
   - Generate filename → parse → verify
   - Parse filename → generate → verify

**Files**: `tests/filename_test.cpp` or extend existing test

**Status**: Covered by `tests/filename_parsing.cpp` (includes term=0 compatibility and term-aware formats).

**Success Criteria**:
- [x] Supported formats parse correctly
- [x] Term-aware formats parse correctly
- [x] Generators produce correct filenames
- [x] Roundtrip tests pass
- [x] Edge cases handled

### 11.2 Manifest serialization tests

**Goal**: Test FileIdTermMapping serialization and deserialization.

**Steps**:
1. Create test file `tests/manifest_test.cpp` or extend existing
2. Test serialization:
   - Empty mapping → count=0
   - Non-empty mapping → correct varint format
   - Multiple entries → all serialized
3. Test deserialization:
   - Valid data → correct mapping
   - Empty data (count=0) → empty mapping
   - Malformed data → handled gracefully
4. Test roundtrip:
   - Serialize → deserialize → verify
   - Multiple mappings → verify all
5. Note:
   - Current design always writes the FileIdTermMapping section (count field at minimum).

**Files**: `tests/manifest_test.cpp` or extend existing

**Status**: Covered by `tests/fileid_term_mapping.cpp` and `tests/manifest_payload.cpp`.

**Success Criteria**:
- [x] Serialization produces correct format
- [x] Deserialization reads correctly
- [x] Roundtrip tests pass
- [x] Error handling tested

### 11.3 Replayer tests

**Goal**: Test replayer term validation and allocator bumping.

**Steps**:
1. Create test file `tests/replayer_test.cpp` or extend existing
2. Test allocator bumping:
   - manifest_term != expect_term in cloud mode → bump occurs
   - manifest_term == expect_term → no bump
   - expect_term == 0 → no bump
   - local mode → no bump
3. Term validation:
   - Future-term rejection is handled in cloud manifest selection (Phase 6); replayer itself only bumps allocator.
4. Test term mapping restoration:
   - Deserialized mapping → restored to PartitionFiles
   - Mapping accessible to other classes
5. Test edge cases:
   - Empty mapping → handled correctly
   - Missing mapping → default term=0
   - Multiple terms → correct handling

**Files**: `tests/replayer_test.cpp` or extend existing

**Status**: Covered by `tests/replayer_term.cpp`.

**Success Criteria**:
- [x] Allocator bumping works correctly
- [x] Edge cases handled

### 11.4 Cloud integration tests

**Goal**: Test cloud manifest selection and file operations with terms.

**Steps**:
1. Create test file `tests/cloud_test.cpp` or extend existing
2. Test manifest download with term selection:
   - Process term manifest exists → downloaded
   - Process term missing → latest downloaded
   - Future term → error returned
3. Test file open with term-aware names:
   - File with term → correct filename used
   - File without term → fallback to process_term
   - Term mismatch → handled correctly
4. Test archive creation with term:
   - Term-aware archive name generated
   - Archive uploaded with correct name
5. Note:
   - Legacy `manifest_<ts>` is no longer supported by parsing/selection logic; tests should avoid creating such filenames.

**Files**: `tests/cloud_test.cpp` or extend existing

**Status**: Covered by existing `tests/cloud.cpp` plus adjustments to avoid legacy `manifest_<ts>` backup names.

**Success Criteria**:
- [x] Manifest selection works correctly
- [x] File operations use term-aware names
- [x] Archive creation works

### 11.5 End-to-end integration tests

**Goal**: Test complete workflows with term-aware functionality.

**Steps**:
1. Test multi-process scenarios:
   - Multiple processes with different terms
   - File allocation across terms
   - Manifest replay with term differences
2. Test term changes:
   - Process restarts with different terms
   - Term changes during runtime (if supported)
3. Test file operations:
   - Write with term-aware names
   - Read with term-aware names
   - Archive with term-aware names
4. Test error scenarios:
   - Future term consumption prevented
   - Term mismatch handling
   - Malformed data handling

**Files**: `tests/integration_test.cpp` or extend existing

**Success Criteria**:
- [ ] Multi-process scenarios work
- [ ] Term changes handled
- [ ] File operations work end-to-end
- [ ] Error scenarios handled
- [ ] Performance acceptable

## Dependencies

- All previous phases (testing depends on implementation)

## Related Phases

- All phases should have corresponding tests

## Design Notes

- Comprehensive test coverage for all functionality
- Unit tests for individual components
- Integration tests for workflows
- Backward compatibility tests
- Error handling tests

## Testing Strategy

- Unit tests: Individual functions and classes
- Integration tests: Component interactions
- End-to-end tests: Complete workflows
- Compatibility tests: term=0 behavior
- Error tests: Error handling and edge cases

