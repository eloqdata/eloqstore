//! Embedded library loader for libeloqstore_combine.so
//!
//! This module handles extracting the embedded .so file to a temporary location
//! and ensuring it's available for the runtime linker.

use std::env;
use std::fs;
use std::path::PathBuf;
use std::sync::{Mutex, Once};

#[cfg(unix)]
use libc::{c_char, c_int, c_void};

#[cfg(unix)]
unsafe extern "C" {
    fn dlopen(filename: *const c_char, flag: c_int) -> *mut c_void;
    fn dlerror() -> *const c_char;
}

static INIT: Once = Once::new();
static EXTRACTED_LIB_PATH: Mutex<Option<PathBuf>> = Mutex::new(None);

/// Ensure the embedded library is extracted and available
/// Returns the path to the extracted library
pub(crate) fn ensure_library_available() -> Result<PathBuf, String> {
    INIT.call_once(|| {
        if let Ok(path) = extract_embedded_library() {
            if let Ok(mut guard) = EXTRACTED_LIB_PATH.lock() {
                *guard = path;
            }
        }
    });
    
    EXTRACTED_LIB_PATH
        .lock()
        .map_err(|e| format!("Mutex poison: {}", e))?
        .as_ref()
        .ok_or_else(|| "Library extraction failed".to_string())
        .map(|p| p.clone())
}

fn extract_embedded_library() -> Result<Option<PathBuf>, Box<dyn std::error::Error + Send + Sync>> {
    // Try to find library in standard locations first
    if let Some(path) = find_library_in_standard_paths() {
        return Ok(Some(path));
    }

    // Extract from embedded data
    // The embedded library will be generated by build.rs in OUT_DIR
    // We use include_bytes! to embed it at compile time
    // Note: include_bytes! reads the file at compile time, not runtime
    let embedded_data = include_bytes!(concat!(env!("OUT_DIR"), "/libeloqstore_combine.so"));
    
    // Create a temporary directory for the extracted library
    let temp_dir = env::temp_dir().join("eloqstore_libs");
    fs::create_dir_all(&temp_dir)?;
    
    let lib_path = temp_dir.join("libeloqstore_combine.so");
    
    // Only extract if it doesn't exist or is different
    let needs_extraction = !lib_path.exists() || {
        fs::read(&lib_path)
            .map(|existing| existing != embedded_data.as_slice())
            .unwrap_or(true)
    };
    
    if needs_extraction {
        fs::write(&lib_path, embedded_data)?;
        
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&lib_path)?.permissions();
            perms.set_mode(0o755);
            fs::set_permissions(&lib_path, perms)?;
        }
    }
    
    // Use dlopen to load the library explicitly
    // This ensures the library is loaded even if the linker can't find it via rpath
    // Note: dlopen only helps if we're using dynamic symbol resolution
    // Since we're linking with -ldl, we can use dlopen to preload the library
    #[cfg(unix)]
    {
        use std::ffi::CString;
        let lib_path_cstr = CString::new(lib_path.to_string_lossy().as_ref())
            .map_err(|e| format!("Invalid library path: {}", e))?;
        
        unsafe {
            const RTLD_LAZY: c_int = 1;
            const RTLD_GLOBAL: c_int = 0x00100; // Make symbols available to subsequently loaded libraries
            let handle = dlopen(lib_path_cstr.as_ptr(), RTLD_LAZY | RTLD_GLOBAL);
            if handle.is_null() {
                let err = dlerror();
                let error_msg = if err.is_null() {
                    "Unknown error".to_string()
                } else {
                    std::ffi::CStr::from_ptr(err)
                        .to_string_lossy()
                        .into_owned()
                };
                return Err(format!("Failed to dlopen library {}: {}", lib_path.display(), error_msg).into());
            }
        }
    }
    
    Ok(Some(lib_path))
}

fn find_library_in_standard_paths() -> Option<PathBuf> {
    // Check relative to executable
    if let Ok(exe) = env::current_exe() {
        if let Some(exe_dir) = exe.parent() {
            // Check same directory
            let lib = exe_dir.join("libeloqstore_combine.so");
            if lib.exists() {
                return Some(lib);
            }
            // Check parent directory
            let lib = exe_dir.parent().map(|p| p.join("libeloqstore_combine.so"));
            if let Some(ref lib) = lib {
                if lib.exists() {
                    return Some(lib.clone());
                }
            }
        }
    }
    
    // Check system paths
    for path in ["/usr/local/lib", "/usr/lib"] {
        let lib = PathBuf::from(path).join("libeloqstore_combine.so");
        if lib.exists() {
            return Some(lib);
        }
    }
    
    None
}
